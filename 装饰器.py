"""
装饰器的俗称是  语法糖
Python的装饰器（fuctional decorators）
作用：用于扩展原来函数的功能的一种高阶函数。装饰器的本质就是函数。
目的是在不改变原函数的基础上给函数增加的新的功能。
这个函数（装饰函数）的特殊之处在于 它的返回值是一个函数名，这个函数是内嵌在“原函数”中的一个函数。

假设有如下一个函数：
def func():
    print("运行func函数")

现在有这样一个要求：要求在此函数前后加上日志打印的功能，
并且 有很多此类型的函数没有日志打印的功能，现在需要都给加上日志打印的功能。
"""

# 修改一下原函数，加上日志打印的功能
# def func():
#     print("函数前打印日志")
#     print("运行func函数")
#     print("函数后打印日志")
# 首先修改原函数存在一定的风险。
# 1、 修改了原函数以后不能确保是没有问题的
# 2、违背了   开放封闭原则（OCP， Open Closed Priciple），是所有面向对象语言的核心
# OCP的核心思想：
# 软件实体应该是可扩展的，而不是可修改的，，也就是说对于扩展是开放的，对于修改是封闭的。
# 封闭：已经实现的功能代码块不应该被修改
# 开放：对现有的功能的扩展是开放的

# 把函数重新编写一下。 保持的原函数不动，重写一个函数 来实现这个功能
# def fuc():
#     print("函数前打印日志")
#     print("运行func函数")
#     print("函数后打印日志")

# 增加了工作量

# 使用装饰器来实现这个功能。
# 闭包：如果在一个函数内部里，对在外部函数内（但不是全局作用域）的变量进行引用，那么内部函数就称之为闭包。

def f(foo):   #  f 是装饰函数，装饰器
    def inner():    # inner函数是闭包
        print("打印日志前")
        foo()      # foo() == func()，相当于这里调用了原函数。
        print("打印日志后")
    return inner   # 返回内部函数的函数名

# 调用了f()函数，传入了一个实参（实参是原函数的函数名），返回 inner（inner是内部函数的函数名）
# a = f(func)   # 所以现在 a == inner
# a()           # a()  ==>  inner()
# 原函数
@f       # 装饰器的使用： 在原函数的上面使用  @加上装饰函数的函数名 即可。
def func():
    print("运行func函数")
# 调用函数
func()
